#'------------------------------------------------------------------------------
#' TRANSFER MONTHLY DATASHEETS TO FILESTORE 
#'
#' OBJECTIVES
#' Transfer the files generated by TLHC DATASHEET OUTPUT to the DATA NEW folder.
#' 
#' 1. Navigate the file system on DATA NEW
#' 2. Test if a file exists already
#'  a. If it exists, then archive the current file and replace with new one
#'  b. If it is new then add to the file system
#' ----------------------------------------------------------------------------

# Libraries
library(tidyverse)   # tidy data processing
library(here)        # localised filepaths
library(lubridate)   # working with dates
library(janitor)
library(unglue)      # extract details from a string
library(tools)
library(furrr)       # parallel processing
library(progressr)   # progress bars
library(tictoc)      # timing monitor

# Notify user 
cat(rep('\n', 50)) # 50 blank lines to clear the console
cat('== phase1_sql_output_transfer =============================================\n')
tic()

# Setup ------------------------------------------------------------------------

# Define variables
path_source = here('data', 'datasheets') # where the datasheets are
path_dest = file.path(Sys.getenv('base_azure'), 'reporting_monthly', 'DATA NEW') # where we want them to go

## user-defined functions ------------------------------------------------------

#' Check whether archive folder exists (and create if not there)
#'
#' @param str_folderpath String folderpath to the folder being checked
#'
#' @return NA
func_check_archive_folder <- function(str_folderpath) {
  if(!dir.exists(str_folderpath)){dir.create(str_folderpath)}
}

#' Move files
#'
#' @param filepath_source String filepath to the file to be moved
#' @param filepath_dest String filepath to the destination for the file
#'
#' @return NA
func_move_files <- function(filepath_source, filepath_dest){
  p() # update progress bar
  
  file.rename(
    from = filepath_source,
    to = filepath_dest
  )
}

# notify user
cat(paste('☑️', Sys.time(), 'Setup complete\n', sep = ' '))

# Load data --------------------------------------------------------------------

## Identify datasheets ---------------------------------------------------------
# List all files in the source folder and exract useful information, such as filename,
# project name, estimated destination filepath, where files ought to be archived to,
# etc.

# List files in the source
df_files_source <- tibble(filepath_source = list.files(path = path_source, full.names = T)) |> 
  # prepare information
  mutate(
    # extract just the filename and extension from the filepath
    filename_source = basename(filepath_source)
  ) 

# extract the destination folder and filename from this
df_files_source <- unglue_unnest(
  data = df_files_source,
  col = filename_source,
  patterns = '{folder_dest}_{yearmonth}_{filename_dest}',
  remove = F
) |> 
  # correct for idiosyncrasies in folder names
  mutate(
    folder_dest_corrected = case_when(
      folder_dest == 'Blackburn with Darwen' ~ 'Blackburn',
      folder_dest == 'Newcastle Gateshead' ~ 'Newcastle',
      folder_dest == 'Tameside and Glossop' ~ 'Tameside',
      TRUE ~ folder_dest
    ),
    # construct a path to this destination file
    filepath_dest = file.path(path_dest, folder_dest_corrected, filename_dest),
    # test whether this file exists
    exists_dest = file.exists(filepath_dest),
    # define an archive folderpath
    archive_folderpath = file.path(
      path_dest, # destination path
      folder_dest_corrected, # destination folder for the project
      'archive' # the name of the archive folder
    ),
    # define an archive filepath for files already existing
    archive_filepath = case_when(
      exists_dest == TRUE ~ file.path(
        # path_dest, # destination path
        # folder_dest_corrected, # destination folder
        # 'archive', # the name of the archive folder
        archive_folderpath, # the path to the archive folder
        paste0(
          str_remove(string = filename_dest, pattern = paste0('.', file_ext(filename_dest))), # destination filename (without extension)
          '_', # spacer
          str_remove_all(as.character(now()), '-|:'), # add a timestamp (without special characters)
          '.', file_ext(filename_dest) # add the file extension back on
        )
      )
    )
  )

## ensure archives exist -------------------------------------------------------

# before we archive files we need to ensure a folder exists for them
# apply the function on all archive folders in the df
lapply(
  X = df_files_source |> select(archive_folderpath) |> unique() |> as_vector(),
  FUN = func_check_archive_folder
)

# notify user
cat(paste('☑️', Sys.time(), 'Archive folders checked\n', sep = ' '))

## archive files ---------------------------------------------------------------

# move files in DATA NEW to archive
handlers(handler_progress(format='[:bar] :percent :eta :message')) # set up the progress indicator
plan(multisession) # set up the parallel processing

with_progress({
  p <- progressor(steps = length(df_files_source |> filter(exists_dest == TRUE) |> select(filepath_source) |> as_vector())) # initialise progress bar
  
  df_files_source |> 
    filter(exists_dest == TRUE) |> # only work with files we know exist
    select(filepath_dest, archive_filepath) |>  # select columns that specify existing location and archived location
    mutate(
      result = future_pmap(
        .l = list(filepath_source = filepath_dest, filepath_dest = archive_filepath),
        .f = func_move_files,
        .options = furrr_options(seed=NULL)
      )
    )
})

# notify user
cat(paste('☑️', Sys.time(), 'Older files have been archived\n', sep = ' '))

## replace with new datasheets -------------------------------------------------

# move the newly created datasheets to DATA NEW
handlers(handler_progress(format='[:bar] :percent :eta :message')) # set up the progress indicator
plan(multisession) # set up the parallel processing

with_progress({
  p <- progressor(steps = length(df_files_source |> select(filepath_source) |> as_vector())) # initialise progress bar
  
  df_files_source |> 
    select(filepath_source, filepath_dest) |>  # select columns that specify existing location and archived location
    mutate(
      result = future_pmap(
        .l = list(filepath_source = filepath_source, filepath_dest = filepath_dest),
        .f = func_move_files,
        .options = furrr_options(seed=NULL)
      )
    )
})

# notify user
cat(paste('☑️', Sys.time(), 'New files copied across\n', sep = ' '))


# update the user
cat(paste('☑️', Sys.time(), 'Script complete ===================================\n', sep = ' '))
toc()